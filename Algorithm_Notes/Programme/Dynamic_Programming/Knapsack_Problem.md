# 规划 - 动态规划 - 背包

## 概述

背包可以称之为动态规划最经典的问题系列之一，虽然模型明显、易于编写，但是放到具体题目中还是有很多花样，因而优化也是多种多样的。对于朴素的背包问题，大体有三种：01背包、完全背包和多重背包。

本文来自**背包九讲**。

## 01背包

### 问题

有$N$件物品和一个容量为$V$的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

### 思路

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即$f[i][v]$表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：$f[i][v]=max(f[i-1][v],f[i-1][v-c[i]]+w[i])$。

这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只牵扯前$i-1$件物品的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为$v$的背包中”；如果放第$i$件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-c[i]$的背包中”，此时能获得的最大价值就是$f[i-1][v-c[i]]$再加上通过放入第$i$件物品获得的价值$w[i]$。

注意$f[i][v]$有意义当且仅当存在一个前$i$件物品的子集，其费用总和为$v$。所以按照这个方程递推完毕后，最终的答案并不一定是$f[N][V]$，而是$f[N][0\cdots V]$的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项$f[i][v-1]$，这样就可以保证$f[N][V]$就是最后的答案。

### 优化

以上方法的时间和空间复杂度均为$O(NV)$，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到$O(V)$。

先考虑上面讲的基本思路如何实现，肯定是有一个主循环$i=1\cdots N$，每次算出来二维数组$f[i][0..V]$的所有值。那么，如果只用一个数组$f[0\cdots V]$，能不能保证第$i$次循环结束后$f[v]$中表示的就是我们定义的状态$f[i][v]$呢？$f[i][v]$是由$f[i-1][v]$和$f[i-1][v-c[i]]$两个子问题递推而来，能否保证在推$f[i][v]$时（也即在第$i$次主循环中推$f[v]$时）能够得到$f[i-1][v]$和$f[i-1][v-c[i]]$的值呢？事实上，这要求在每次主循环中我们以$v=V\cdots 0$的顺序推$f[v]$，这样才能保证推$f[v]$时$f[v-c[i]]$保存的是状态$f[i-1][v-c[i]]$的值。代码如下：

```cpp
for (int i = 1; i <= N; i++) 
	for (int v = V; v >= 0; v--) 
		f[v] = max(f[v], f[v - c[i]] + w[i]);
```

其中的$f[v]=max(f[v],f[v-c[i]])$一句恰就相当于我们的转移方程$f[i][v]=max(f[i-1][v],f[i-1][v-c[i]])$，因为现在的$f[v-c[i]]$就相当于原来的$f[i-1][v-c[i]]$。如果将$v$的循环顺序从上面的逆序改成顺序的话，那么则成了$f[i][v]$由$f[i][v-c[i]]$推知，与本题意不符，但它却是另一个重要的背包问题**完全背包问题**最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。

## 完全背包

### 问题

有$N$种物品和一个容量为$V$的背包，每种物品都有无限件可用。第$i$种物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

### 思路

这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：$f[i][v]=max\{f[i-1][v-k*c[i]]+k*w[i]\ |\ 0\leqslant k*c[i]\leqslant v\}$。这跟01背包问题一样有$O(NV)$个状态需要求解，但求解每个状态的时间则不是常数了，求解状态$f[i][v]$的时间是$O(v/c[i])$，总的复杂度是超过$O(VN)$的。

将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。

### 优化

完全背包问题有一个很简单有效的优化，是这样的：若两件物品$i,j$满足$c[i]\leqslant c[j]且w[i]\geqslant w[j]$，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的$j$换成物美价廉的$i$，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。

**转化为01背包问题求解？**

既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第$i$种物品最多选$V/c[i]$件，于是可以把第$i$种物品转化为$V/c[i]$件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。

更高效的转化方法是：把第$i$种物品拆成费用为$c[i]*2^k$、价值为$w[i]*2^k$的若干件物品，其中$k$满足$c[i]*2^k<V$。这是二进制的思想，因为不管最优策略选几件第$i$种物品，总可以表示成若干个$2^k$件物品的和。这样把每种物品拆成$O(log(V/c[i]))$件物品，是一个很大的改进。但我们有更优的$O(VN)$的算法。

$O(VN)$的算法这个算法使用一维数组，先看代码：

```cpp
for (int i = 1; i <= N; i++)
  	for (int v = 0; v <= V; v++)
		f[v] = max(f[v], f[v - c[i]] + w[i]);
```

你会发现，这个代码与01背包的代码只有$v$的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么01背包中要按照$v=V\cdots 0$的逆序来循环。这是因为要保证第$i$次循环中的状态$f[i][v]$是由状态$f[i-1][v-c[i]]$递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第$i$件物品”这件策略时，依据的是一个绝无已经选入第$i$件物品的子结果$f[i-1][v-c[i]]$。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第$i$种物品”这种策略时，却正需要一个可能已选入第$i$种物品的子结果$f[i][v-c[i]]$，所以就可以并且必须采用$v=0\cdots V$的顺序循环。这就是这个简单的程序为何成立的道理。

这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：$f[i][v]=max(f[i-1][v],f[i][v-c[i]]+w[i])$，将这个方程用一维数组实现，便得到了上面的代码。

## 多重背包

### 问题

有$N$种物品和一个容量为$V$的背包。第$i$种物品最多有$n[i]$件可用，每件费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

### 思路

这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第$i$种物品有$n[i]+1$种策略：取$0$件，取$1$件……取$n[i]$件。令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值，则：$f[i][v]=max\{f[i-1][v-k*c[i]]+ k*w[i]\ |\ 0\leqslant k\leqslant n[i]\}$。复杂度是$O(V*∑n[i])$。


**转化为01背包问题？**

另一种好想好写的基本方法是转化为01背包求解：把第$i$种物品换成$n[i]$件01背包中的物品，则得到了物品数为$∑n[i]$的01背包问题，直接求解，复杂度仍然是$O(V*∑n[i])$。

### 优化

但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第$i$种物品换成若干件物品，使得原问题中第$i$种物品可取的每种策略——取$0\cdots n[i]$件——均能等价于取若干件代换以后的物品。另外，取超过$n[i]$件的策略必不能出现。

方法是：将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为$1,2,4,...,2^{k-1},n[i]-2^k+1$，且$k$是满足$n[i]-2^k+1>0$的最大整数。例如，如果$n[i]$为$13$，就将这种物品分成系数分别为$1,2,4,6$的四件物品。

分成的这几件物品的系数和为$n[i]$，表明不可能取多于$n[i]$件的第$i$种物品。另外这种方法也能保证对于$0\cdots n[i]$间的每一个整数，均可以用若干个系数的和表示，这个证明可以分$0\cdots 2^k-1$和$2^k\cdots n[i]$两段来分别讨论得出，并不难，希望你自己思考尝试一下。

这样就将第$i$种物品分成了$O(log\ n[i])$种物品，将原问题转化为了复杂度为$O(V*∑log\ n[i])$的01背包问题，是很大的改进。

**O(VN)的算法？**

多重背包问题同样有$O(VN)$的算法。这个算法基于基本算法的状态转移方程，但应用**单调队列**的方法使每个状态的值可以以均摊$O(1)$的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。

## 混合背包

### 问题

如果将上述三种背包问题混合起来，也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？